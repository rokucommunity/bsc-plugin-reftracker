import "pkg:/source/roku_modules/promises/promises.brs"

const MAX_WORK_QUEUE_DURATION = 5000000000000
' typecast m as mm

interface mm
    ___reftracker_reftrackers as roSGNodeReftracker[]
    ___reftracker_processedItems as roAssociativeArray
    ___reftracker_deviceInfo as roDeviceInfo
    ___reftracker_workQueue as roArray
end interface


namespace reftracker

    ' Find all references to a SceneGraph node by its ID
    function findNodeById(id as string)
        'build the reftracker
        tracker = createObject("roSGNode", "Reftracker")
        'store a reference to it so it doesn't get lost
        reftracker.internal.registerReftracker(tracker)
        'run it
        return tracker@.discover()
    end function
end namespace


namespace reftracker.internal

    ' This is a generic function injected into every component as a callfunc, to be a single point of contact for all commands.
    '@param {ExecuteOptions} options
    function execute(options)
        if options.command = "discover"
            registerWorkItem(options.keypath, "m", m)
            return processWorkItems(options)
        else
            return promises.reject({
                message: "Unknown command"
            })
        end if
    end function

    function getWorkQueue() as WorkQueueItem[]
        if m.___reftracker_workQueue = invalid
            m.___reftracker_workQueue = []
        end if
        return m.___reftracker_workQueue
    end function

    ' register some item to be processed later
    function registerWorkItem(parentKeypath as string, key as string, item as dynamic) as void
        if isReftrackerProperty(key)
            writeLog("skipping reftracker property", `${parentKeypath}.${key}`, type(item))
            return
        end if

        if item <> invalid
            workQueue = getWorkQueue()

            workQueue.push({
                parentKeypath: parentKeypath,
                keypath: `${parentKeypath}.${key}`,
                key: key,
                item: item
            })
        end if
    end function

    function processWorkItems(options as reftracker.internal.ProcessOptions) as roSGNodepromises_Promise
        startTime = createObject("roTimeSpan")

        workQueue = getWorkQueue()

        'if we have work, and we've been running for less than 500ms, process another item
        while workQueue[0] <> invalid and startTime.TotalMilliseconds() < MAX_WORK_QUEUE_DURATION
            try
                workItem = workQueue.Shift()

                item = workItem.item
                itemKeypath = `${workItem.parentKeypath}.${workItem.key}`

                itemType = type(item)

                'if this is a node, push register it with the reftracker to be processed later
                if itemType = "roSGNode"
                    writeLog("item is a node. pushing to node queue", itemKeypath, itemType)
                    options.reftracker@.registerNodeRef(workItem.parentKeypath, workItem.key, item)
                else if itemType = "roArray"
                    if isProcessed(item)
                        writeLog("item is an array and already processed. Skipping", itemKeypath, itemType)
                    else
                        markProcessed(item)
                        writeLog("item is an array. registering all entries", itemKeypath, itemType)
                        'if this is an array, register each item in the array
                        for i = 0 to (item as ifArray).Count() - 1
                            value = item[i]
                            'if we encountered the reftracker property, we can stop processing the rest of this array (because it ends with [___reftracker_id, "<the-id>"])
                            if isReftrackerProperty(value)
                                exit for
                            end if
                            registerWorkItem(itemKeypath, i.ToStr(), item[i])
                        end for
                    end if
                else if itemType = "roAssociativeArray"
                    if isProcessed(item)
                        writeLog("item is an AA and already processed. skipping", itemKeypath, itemType)
                    else

                        markProcessed(item)
                        writeLog("item is an AA. registering all properties", itemKeypath, itemType)
                        'if this is an associative array, register each item in the array
                        for each key in item
                            value = item[key]
                            reftracker.internal.registerWorkItem(itemKeypath, key, item[key])
                        end for
                    end if
                else
                    'all other data types can be ignored, since they don't include references to other nodes
                    writeLog("skipping item because it does not support storing node references", itemKeypath, itemType)
                end if
            catch e
                writeLog(`Error processing work item: ${FormatJson(e)}`, itemKeypath, "")
            end try
        end while

        'we have no more work, return a resolved promise
        if workQueue[0] = invalid
            writeLog("work queue is complete", options.keypath)
            'TODO clean up
            return promises.resolve(true)
        end if

        'small delay, then process work again
        return promises.chain(reftracker.internal.delay(.01), options).then(function(result, options)
            'process work items again
            return processWorkItems(options)
        end function).toPromise()
    end function

    'check if an item has already been processed
    function isProcessed(item as dynamic)
        return false
        if m.___reftracker_processedItems = invalid
            m.___reftracker_processedItems = {}
        end if

        id = getReftrackerId(item)
        'if we've processed this item, it'll have its id in the processedItems array
        return m.___reftracker_processedItems[id] = true
    end function

    'mark an item as processed so we know to skip it in the future
    function markProcessed(item as dynamic) as void
        return
        if m.___reftracker_processedItems = invalid
            m.___reftracker_processedItems = {}
        end if

        id = getReftrackerId(item)
        'if we've processed this item, it'll have its id in the processedItems array
        m.___reftracker_processedItems[id] = true
    end function

    'Ensure this node has a unique reftracker id so we can use it for lookups and equality checks
    function getReftrackerId(item as dynamic) as string
        reftrackerId = reftracker.internal.getRandomUUID()
        key = "___reftracker_id"
        itemType = type(item)
        if itemType = "roSGNode"
            if item[key] = invalid then
                item.addField(key, "string", false)
                item[key] = reftrackerId
            end if
            return item[key]
        else if itemType = "roAssociativeArray"
            if item[key] = invalid then
                item[key] = reftrackerId
            end if
            return item[key]
        else if itemType = "roArray"
            nextToLastArrayValue = item[(item as roArray).Count() - 2]
            if not isString(nextToLastArrayValue) or (isString(nextToLastArrayValue) and nextToLastArrayValue <> key)
                item.push(key)
                item.push(reftrackerId)
            end if
            return item[(item as roArray).Count() - 1]
        end if
        'return invalid, which will probably crash outside (that's desired to identify issues)
        return invalid
    end function

    function registerReftracker(finder as roSGNodeRefTracker)
        if m.___reftracker_reftrackers = invalid
            m.___reftracker_reftrackers = []
        end if
        m.___reftracker_reftrackers.push(finder)
    end function

    function getDeviceObject() as object
        if m.___reftracker_deviceInfo <> invalid then return m.___reftracker_deviceInfo
        m.___reftracker_deviceInfo = createObject("roDeviceInfo")
        return m.___reftracker_deviceInfo
    end function

    ' Get a promise that resolves after a given duration
    sub delay(duration = 0.0001 as float) as roSGNodepromises_Promise
        timer = createObject("roSGNode", "Timer")
        timer.duration = duration
        timer.repeat = false
        timer.id = "___reftracker_delay_" + getRandomUUID()

        promise = promises.create()

        m[timer.id] = {
            timer: timer
            promise: promise
        }

        timer.observeFieldScoped("fire", (sub(event as object)
            delayId = event.getNode()
            options = m[delayId]
            promise = options.promise
            promises.resolve(promise, invalid)
            m[delayId].timer.unobserveFieldScoped("fire")
            m.delete(delayId)
        end sub).toStr().mid(10))

        timer.control = "start"
        return promise
    end sub

    function getRandomUUID()
        return getDeviceObject().getRandomUUID()
    end function

    function isNode(value as dynamic, subtype = "" as string)
        return type(value) = "roSGNode" and (subType = "" or value.isSubtype(subType))
    end function

    interface ExecuteOptions
        command as string
        keypath as string
        reftracker as roSGNodeReftracker
    end interface

    interface ProcessOptions
        reftracker as roSGNodeReftracker
        keypath as string
    end interface

    interface WorkQueueItem
        parentKeypath as string
        key as string
        item as dynamic
    end interface

    'All reftracker properties are prefixed with ___reftracker_ , so this method can be used to filter them out
    function isReftrackerProperty(key as dynamic)
        return isString(key) and key.left(14) = "___reftracker_"
    end function

    function writeLog(message as string, keypath = "" as string, typeInfo = "" as string)
        keypath = `${keypath}`
        text = keypath = "" ? "[ref]" : `[ref:${keypath}]`
        text += ` ${message}`
        if typeInfo <> ""
            text += ` (${typeInfo})`
        end if
        print text
    end function

    function isString(value as dynamic) as boolean
        return type(value) = "String" or type(value) = "roString"
    end function

    function printError(error as dynamic)
        if isNonEmptyAA(error) and isArray(error.backtrace) then
            newItem = {}
            newItem.append(error)
            newBackTrace = chr(10)
            for each backtrace in newItem.backtrace
                newBackTrace += "        file/line: " + backtrace.fileName + `(${backtrace.line_number})` + chr(10)
                newBackTrace += "        Function " + backtrace.function + chr(10) + chr(10)
            end for
            newBackTrace = newBackTrace.trim()
            if newBackTrace <> "" then newBackTrace = chr(10) + "        " + newBackTrace
            newItem.backtrace = newBackTrace
            print newItem; " "
        else
            print error; " "
        end if
    end function

    function isNonEmptyAA(value as dynamic) as boolean
		return type(value) = "roAssociativeArray" and not value.isEmpty()
	end function

    function isArray(value as dynamic) as boolean
		return type(value) = "roArray"
	end function
end namespace
