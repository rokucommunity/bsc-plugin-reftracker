import "pkg:/source/reftrackerLib.bs"
import "pkg:/source/roku_modules/promises/promises.brs"

' typecast m as ReftrackerM
interface ReftrackerM
    nodesByKeypath as ifAssociativeArray
    keypathsByNodeReftrackerId as ifAssociativeArray
    allNodes as roSGNode[]
    nodeQueue as NodeQueueItem[]
    top as roSGNodeReftracker
end interface

function init()
    'build several parallel lookups for nodes to simplify discoverability later

    ' a lookup of nodes by their keypath
    m.nodesByKeypath = {}
    'a lookup of all keypaths for a node indexed by the node's reftrackerId
    m.keypathsByNodeReftrackerId = {}
    'a flat list of all nodes discovered in this run
    m.allNodes = []
    'a queue of nodes to process
    m.nodeQueue = []

    m.top.runId = reftracker.internal.getRandomUUID()
end function

function discover(_ = invalid)
    'seed the list of nodes with all roots (should be a good starting point)
    for each root in m.top.getRoots() as roSGnode[]
        registerNodeRef(`root:<${root.subtype()}>`, root)
    end for

    'process the nodes one-by-one
    return promises.onThen(processNodes(), function(result)
        printNodes()
    end function)
end function

function printNodes()
    print FormatJson(m.keypathsByNodeReftrackerId)
end function

'Register a reference to a node so we can process it later. This
function registerNodeRef(keypath as string, node as roSGNode)
    reftrackerId = reftracker.internal.getReftrackerId(node)

    'store a reference to the node by its keypath
    m.nodesByKeypath[keypath] = node

    isNewNode = m.keypathsByNodeReftrackerId[reftrackerId] = invalid

    if isNewNode
        'build a new array to store all the keypaths for this node
        m.keypathsByNodeReftrackerId[reftrackerId] = []
        'if this is the first time we've seen this node, store it in our list of all nodes
        m.allNodes.push(node)

        'register this node for future evaluation
        m.nodeQueue.push({
            keypath: keypath,
            node: node
        })
    end if
    m.keypathsByNodeReftrackerId[reftrackerId].push(keypath)
end function

function processNodes()
    'if we have no more nodes, we are done!
    if m.nodeQueue.count() = 0
        reftracker.internal.writeLog("All nodes have been processed. Exiting node process loop")
        return promises.resolve(invalid)
    end if

    queueItem = m.nodeQueue.pop() as NodeQueueItem

    reftracker.internal.writeLog("processing node", queueItem.keypath, queueItem.node.subtype())

    'if this node supports reftracker functionality, process the node's internal `m`
    return promises.chain(promises.resolve(true), queueItem).then(function(result, queueItem as NodeQueueItem)
        if (queueItem.node as dynamic).reftrackerEnabled then
            reftracker.internal.writeLog("processing node's internal m properties", queueItem.keypath, queueItem.node.subtype())
            return queueItem.node@.reftracker_internal_execute({
                command: "discover",
                reftracker: m.top,
                keypath: queueItem.keypath
            })
        else
            reftracker.internal.writeLog("node does not support reftracker intraspection", queueItem.keypath, queueItem.node.subtype())
        end if

        'add all public fields to a list of stuff to work on
    end function).then(function(result, queueItem as NodeQueueItem)
        reftracker.internal.writeLog("processing node fields", queueItem.keypath, queueItem.node.subtype())
        for each fieldName in queueItem.node.getFields()
            value = queueItem.node[fieldName]
            reftracker.internal.registerWorkItem(queueItem.keypath, fieldName, value)
        end for

        'now process this data (it will run async and process in chunks until all are finished)
        return reftracker.internal.processWorkItems({
            reftracker: m.top,
            keypath: queueItem.keypath
        })

        'now process the next node
    end function).then(function(result, queueItem as NodeQueueItem)
        reftracker.internal.writeLog("Processing next node")
        return processNodes()
    end function).catch(function(error, _)
        print FormatJson(error)
    end function).toPromise()
end function

interface NodeQueueItem
    keypath as string
    node as roSGNode
end interface
